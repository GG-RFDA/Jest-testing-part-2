// Подключаем Lodash
const Lodash = require("./sync");

/*
 * Поскольку напрямую мы не можем вызвать методы, то необходимо создать инстанс класса.
 * В _ положим значение класса new Lodash().
 */
let _ = new Lodash();

describe("Класс Lodash: функция compact", () => {
	let array = [false, 14, 0, "", true, null, "hello"];

	// Создаём функцию beforeEach, которая будет вызываться перед каждым тестом
	beforeEach(() => {
		// Создаём массив и заполняем его данными
		array = [false, 14, 0, "", true, null, "hello"];
	});

	// Создаём функцию afterAll, которая будет вызываться после всех тестов
	afterAll(() => {
		_ = new Lodash();
	});

	// Создаём сценарий, где ожидаем определения функции
	test("должна быть определена", () => {
		// Функция должна быть определена
		expect(_.compact).toBeDefined();
		// Функция не должна быть undefined
		expect(_.compact).not.toBeUndefined();
	});

	// Создаём сценарий, где ожидаем, что массив можно редактировать
	test("должна иметь массив, который можно редактировать", () => {
		// Добавляем в массив два новых элемента
		array.push(...["one", "two"]);
		// Ожидаем, что в массиве есть значение one
		expect(array).toContain("one");
		// Ожидаем, что в массиве есть значение two
		expect(array).toContain("two");
	});

	// Создаём сценарий, где ожидаем удаление функцией ложных значений из массива
	test("должна убрать ложные значения из массива", () => {
		const result = [14, true, "hello"];
		// Пропускаем массив через функцию compact и ожидаем, что результат вычисления будет равен массиву result
		expect(_.compact(array)).toEqual(result);
	});

	// Создаём сценарий, где ожидаем удаление функцией ложных значений из массива
	test("не должна содержать falsy значений", () => {
		// Ожидаем, что массив не должен содержать ложных значений
		expect(_.compact(array)).not.toContain(false);
		expect(_.compact(array)).not.toContain(0);
		expect(_.compact(array)).not.toContain("");
		expect(_.compact(array)).not.toContain(null);
	});
});

describe("Класс Lodash: функция groupBy", () => {

    // Создаём сценарий по аналогии с предыдущим для функции compact
	test("должна быть определена", () => {
		expect(_.groupBy).toBeDefined();
		expect(_.groupBy).not.toBeUndefined();
	});

    // Создаём сценарий с группировкой элементов массива с помощью функции Math.floor
	test("должна группировать элементы массива при помощи функции Math.floor", () => {
        // Создаём массив и заполняем его данными
		const array = [2.2, 2.4, 4.2, 3.5];
        // Создаём переменную result, в котором будет храниться объект
		const result = {
            // У объекта будет 3 ключа, где у каждого будут определённые значения
			2: [2.2, 2.4],
			4: [4.2],
			3: [3.5],
		};
        // Ожидаем, что массив array, обработанный при помощи функции Math.floor, будет равен переменной result
		expect(_.groupBy(array, Math.floor)).toEqual(result);
	});

    // Создаём сценарий с группировкой элементов массива по кол-ву символов
	test("должна группировать элементы массива по кол-ву символов", () => {
        // Создаём массив и заполняем его данными
		const array = ["one", "two", "three"];
        // Создаём переменную result, в котором будет храниться объект
		const result = {
            // У объекта будет 2 ключа, где у каждого будут определённые значения 
			5: ["three"],
			3: ["one", "two"],
		};
        // Ожидаем, что массив array, обработанный при помощи length, будет равен переменной result
		expect(_.groupBy(array, "length")).toEqual(result);
	});

    // Создаём сценарий, где функция не возвращает массив
	test("не должна возвращать массив", () => {
        // Ожидаем, что пропуская что-то через groupBy и функцию Math.trunc, значение не должно быть экземпляром класса Array
		expect(_.groupBy([], Math.trunc)).not.toBeInstanceOf(Array);
	});
});
